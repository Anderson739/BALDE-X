<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mini Fortnite JS</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; font-family: sans-serif; }
        canvas { display: block; }
        
        /* Interface Mobile */
        #joystick-container {
            position: absolute; bottom: 40px; left: 40px;
            width: 120px; height: 120px; background: rgba(255,255,255,0.2);
            border-radius: 50%; touch-action: none;
        }
        #joystick-knob {
            position: absolute; top: 35px; left: 35px;
            width: 50px; height: 50px; background: white;
            border-radius: 50%; transition: transform 0.1s;
        }
        #shoot-btn {
            position: absolute; bottom: 60px; right: 40px;
            width: 80px; height: 80px; background: rgba(255, 0, 0, 0.6);
            border-radius: 50%; color: white; border: none; font-weight: bold;
        }
        #ui {
            position: absolute; top: 20px; left: 20px; color: white;
            text-shadow: 2px 2px 4px #000; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>MINI FORTNITE</h1>
        <p>Ennemis restants: <span id="count">5</span></p>
    </div>

    <div id="joystick-container"><div id="joystick-knob"></div></div>
    <button id="shoot-btn">FEU</button>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CONFIGURATION SCÈNE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); // Ciel
        scene.fog = new THREE.Fog(0x87CEEB, 20, 100);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(10, 20, 10);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- MAP (SOL ET DÉCOR) ---
        const floorGeo = new THREE.PlaneGeometry(200, 200);
        const floorMat = new THREE.MeshStandardMaterial({ color: 0x2d5e1e });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Ajout de quelques obstacles (murs/maisons simplifiées)
        for(let i=0; i<15; i++) {
            const box = new THREE.Mesh(
                new THREE.BoxGeometry(4, 4, 4),
                new THREE.MeshStandardMaterial({color: 0x8B4513})
            );
            box.position.set(Math.random()*80-40, 2, Math.random()*80-40);
            box.castShadow = true;
            scene.add(box);
        }

        // --- JOUEUR ---
        const playerGroup = new THREE.Group();
        const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.5, 1, 4, 8), new THREE.MeshStandardMaterial({color: 0x3333ff}));
        body.position.y = 1;
        playerGroup.add(body);
        scene.add(playerGroup);

        camera.position.set(0, 5, 10);
        playerGroup.add(camera); // Caméra suit le joueur

        // --- ENNEMIS ---
        const enemies = [];
        const enemyCountSpan = document.getElementById('count');
        
        function spawnEnemy() {
            const enemy = new THREE.Mesh(
                new THREE.BoxGeometry(1, 2, 1),
                new THREE.MeshStandardMaterial({color: 0xff0000})
            );
            enemy.position.set(Math.random()*60-30, 1, Math.random()*60-30);
            scene.add(enemy);
            enemies.push(enemy);
        }
        for(let i=0; i<5; i++) spawnEnemy();

        // --- CONTRÔLES TACTILES (JOYSTICK) ---
        let moveData = { x: 0, y: 0 };
        const joystick = document.getElementById('joystick-knob');
        
        document.getElementById('joystick-container').addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            const rect = e.currentTarget.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            
            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
            const angle = Math.atan2(dy, dx);
            
            moveData.x = (Math.cos(angle) * dist) / 50;
            moveData.y = (Math.sin(angle) * dist) / 50;
            
            joystick.style.transform = `translate(${moveData.x * 40}px, ${moveData.y * 40}px)`;
        });

        document.getElementById('joystick-container').addEventListener('touchend', () => {
            moveData = { x: 0, y: 0 };
            joystick.style.transform = `translate(0px, 0px)`;
        });

        // --- SYSTÈME DE TIR ---
        const bullets = [];
        document.getElementById('shoot-btn').addEventListener('touchstart', () => {
            const bGeo = new THREE.SphereGeometry(0.2);
            const bMat = new THREE.MeshBasicMaterial({color: 0xffff00});
            const bullet = new THREE.Mesh(bGeo, bMat);
            
            bullet.position.copy(playerGroup.position);
            bullet.position.y += 1;
            
            // Direction face au joueur
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(playerGroup.quaternion);
            bullet.userData.velocity = direction.multiplyScalar(0.8);
            
            scene.add(bullet);
            bullets.push(bullet);
        });

        // --- BOUCLE D'ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            // Déplacement Joueur
            if (Math.abs(moveData.x) > 0.1 || Math.abs(moveData.y) > 0.1) {
                playerGroup.translateZ(moveData.y * 0.2);
                playerGroup.rotation.y -= moveData.x * 0.05;
            }

            // Gestion des balles
            bullets.forEach((b, index) => {
                b.position.add(b.userData.velocity);
                
                // Collision avec ennemis
                enemies.forEach((en, enIdx) => {
                    if (b.position.distanceTo(en.position) < 1.5) {
                        scene.remove(en);
                        enemies.splice(enIdx, 1);
                        scene.remove(b);
                        bullets.splice(index, 1);
                        enemyCountSpan.innerText = enemies.length;
                    }
                });

                // Nettoyage balles loin
                if(b.position.length() > 100) {
                    scene.remove(b);
                    bullets.splice(index, 1);
                }
            });

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
